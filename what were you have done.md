//1.
//对于二项式系数的乘积，应对过分大的情况
n*(n-1)*(n-2)*(n-3)/24-->
n*(n-1)/2*(n-2)/3*(n-3)/4
//尚且不清楚为什么能AC
//不过小数点的精确计算很迷
/***n和n-1一定有一个是２的倍数，因此２可以除尽，
同理n,n-1,n-2中一定有一个是３的倍数，因此３可以除尽（除掉２只会消除因数２而对３没有影响）
同理４也可以除尽***/

//2.一个很棒的数组处理
apper[s[i]-'a']++;

//3.关于位数的问题
bool ws(int k)  //位数
    {
        if(k>=10 && k<100 && k!=11 || k>=1000 && k<10000)return false;
        if(k>=100000 && k<1000000 || k>=10000000 && k<100000000)return false;
        return true;
    }//洛谷题解上抄的，id-name:linyorson,致谢
    //其实不用傻哈哈地用循环确定精确的位数（是我本人了🥀），达到目的就行；
    //目的在于，偶数位必然不符合，If判断，筛选完事
//4.关于素数
 bool ss(int k)   //素数
    {     
        for(int i=3;i*i<=k;i+=2)if(k%i==0)return false;//+2节省一些     
        return true;
    }
    //（1）线性筛
    int vis[MAXN];
int prime[MAXN];
void Prime()
{
	int cnt=0;
	for(int i=2;i<=n;i++)
    {
        if(!vis[i]) prime[cnt++]=i;
        for(int j=0;j<cnt&&i*prime[j]<=n;j++)
        {
            vis[i*prime[j]]=i;
            if(i%prime[j]==0) break;
        }
    }
}
//（2）埃拉托斯特尼筛
const int MAXN = 1000000；  
void Prime()  
{  
    for (int i=0; i<MAXN; i++) prime[i]=1;  //先把每个数都定义为合数
    prime[0]=prime[1]=0;  
    for (int i=2; i<MAXN; i++)  
    {  
        if (!prime[i]) continue;  
        for (int j=i*2; j<MAXN; j+=i) prime[j] = 0;  //将i的倍数标记为合数
    }  
}
//洛谷题解搬运，id-name:SocietyNiu
//不会但我能存

2022-01-19
最近的错误：
1.不考虑特殊情况：a.最多质数，限度n<=2没有考虑b.指针为空不写c.铺地毯不考虑没有覆盖的地方
2.看错题目a.要求倒序输出，愣是顺序输出b.不要求换行愣是换行c.读题目理解错输入的数字含义
3.写链表创建失败原因：temp->next=p;p=temp;写成这个循环了...牛的...
4.输入七个数字，循环要求了34次...

2022-01-20
1.幻方
2.独木桥
（、、、

## 2022寒假牛客算法入门比赛

[^]: 思维：括题目做法的灵感难 度、思考难度、思考深度等方面；知识:出该题目所需知识的要求，包括但不限于题目对算法；实现：实现该题算法的代码难度，包括对实现技巧的要求、对



好多题都没有思路 仿佛脑子停滞了。其实很多题抛开思维就是经验之谈了，发现着手点，然后很轻松找到知识点（前提是思维是正确的），最后就是板子+变形。赛后看别人的代码，模拟代码运行很容易就知道码题人的思路了（证明对方很强，写代码别人很轻松能读懂，一对比发现自己蒟蒻欸）。

### 第一场

难度 💡💡💡💡💡

完成度🎈🎈🎈:

一道动态计算最大距离，一个for+max（）解决

两道数学题，推公式

有一个牛牛看云：Σ*i*=1*n*Σ*j*=*i**n*∣*a**i*+*a**j*−1000∣

这个硬开for会爆时间；究其本质，一串数中会相加的数就是各两两相加，所以用排列组合的知识就可以解决

`for(int i=1;i<=n;i++)
	{
		int tem=0;
		cin>>tem;
		a[tem]++;
	}
	for(int i=0;i<=1000;i++){
		for(int j=i;j<=1000;j++){
			if(i==j)ans=ans+abs(i+j-1000)*(a[i]*(a[j]-1)/2+a[i]);
			else{
				ans=ans+abs(i+j-1000)*a[i]*a[j];
			} 
		}
	}`

### 第二场

难度：💡💡💡💡

AC:🎈🎈

一道模拟：

`#include<iostream>
using namespace std;
int cnt[10];
int main(){
    string s;cin>>s;
    for(char ch=s[i],int i=0;i<s.size()；i++)`

`if(ch!='5')cnt[ch-'0']++,cnt[5]++;//
    for(int i=1;i<=9;i++)cout<<cnt[i]<<" ";
}`

一道贪心+模拟

`#include<iostream>
using namespace std;
int main(){
    long long x,a,b;cin>>x>>a>>b;
    string s;cin>>s;
    int len=0;
    for(char ch:s)
        if(ch=='1'&&x>=a)len++,x-=a;
        else x+=b;
    cout<<len;
}`

`以后不要自作多情，考虑什么体力不够,要不要不接球...`

尬住的原因是：理解题意捏，不操作就能加

### 第三场

难度：💡💡💡💡

AC:🎈🎈

hello world ＆01串，要求字符不同---有一个不同就行

其他：

.1.模拟：

这6个条件可以拆开分别考虑。 

 同时这6个条件在固定所选子串的其中一个端点后，另一个端点的合法性是单调的。 

 所以可以使用二分或者尺取的方式直接判断每一个条件的合法区间。 

 最后取一个合法区间的并集即可。

2.欧拉回路

3.位运算

4.二分或结论

5.桶，并查集，逆元

### 第四场

难度：💡

AC:🎈🎈🎈🎈🎈

1.f*(*x)=1

或者f(⌊x/2⌋)+f(⌈x/2⌉)x=1  x*≥2

这是原数返回

2.由于输出是浮点数，所以可以用pow函数。一般整数的乘方不建议用pow函数（容易出现精度问题），建议用for循环或者快速幂进行模拟。

3.本题要求构造一个数yyy，为给定的数xxx的倍数，并且二进制下包含xxx的子串，并且 yyy 中'1'的数量和 xxx 中 '1'的数量不能相等。

如果没有最后一个条件，输出 2x 2x2x 即可。因为 2x2x2x 是 xxx 的二进制后面添加一个 '0'，显然满足前两个条件。

现在有了 '1' 数量不等的限制条件，那么就不能用上面的方式构造。

一个最简单的构造方式就是，将 xxx 的二进制重复写两次。显然满足子串条件和'1'不等条件。倍数条件也很容易证明：将 xxx 的二进制写两次等价于将 xxx 后面添加一些'0'，再加上 xxx。而第一步操作也就是乘上一个2的幂，显然一直都满足是xxx的倍数这一条件。

#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    ll x;
    cin>>x;
    int i;
    for(i=0;i<=32;i++)if(1LL<<i>x)break;
    cout<<x*(1LL<<i)+x;

}

4.读题啊啊啊

'<' 代表降八度，'>'代表升八度。那么用一个变量统计当前八度的情况，然后对应哪个音直接输出即可，后面根据八度的情况来添加对应数量的'.'或者'*'即可。

#include<bits/stdc++.h>
using namespace std;
int main(){
    int cnt=0,i;
    string s;
    cin>>s;
    for(i=0;i<s.length();i++){
        if (s[i]=='>')cnt++;
        else if(s[i]=='<')cnt--;
        else{
            if(s[i]=='C')cout<<1;
            if(s[i]=='D')cout<<2;
            if(s[i]=='E')cout<<3;
            if(s[i]=='F')cout<<4;
            if(s[i]=='G')cout<<5;
            if(s[i]=='A')cout<<6;
            if(s[i]=='B')cout<<7;
            if(cnt>0)for(int j=0;j<cnt;j++)cout<<'*';
            else for(int j=cnt;j<0;j++)cout<<'.';
        }//不清零最妙了，保存了影响
    }
    cout << endl;
}

5.差分介绍：

一个数组，有多次操作，每次对某个区间 [l,r][l,r][l,r] 上每个数加上 xxx，问最终的数组是什么样子。

我们不妨假设初始的数组全是0。当我们对 [l,r][l,r][l,r] 区间上每个数加上 xxx 以后，这个数组就变成了 0,0,...,0,x,x,...,x,0,0,0

如果我们只对两个位置的数进行操作：a[l]+=x,a[r+1]−=xa[l]+=x,a[r+1]-=xa[l]+=x,a[r+1]−=x，当我们做一次前缀和以后，我们发现，这个数组就变成了我们想要的样子。（前缀和是指，对于新数组 sumsumsum，sum[i]sum[i]sum[i] 代表a数组中前i项之和。sumsumsum 数组可以通过 sum[i]=sum[i−1]+a[i]sum[i]=sum[i-1]+a[i]sum[i]=sum[i−1]+a[i] 得出）。

因此我们可以先对每个区间修改只修改两个数：a[l]+=x,a[r+1]−=xa[l]+=x,a[r+1]-=xa[l]+=x,a[r+1]−=x，在最后做一次前缀和就可以了。这就是差分的基本思想。

进阶：如果这道题，t*t* 和 a_i*a**i* 的数据范围是 10^9109 怎么做？（提示：离散化）

6.本题要求一个固定的点到一条折线的最短距离。由于折线可以看成是很多条线段，所以可以规约成点到线段的最短距离。

（虽然这个是板子，但不建议直接去[百度]()，毕竟赛场上没有[百度]()）

显然，最终的答案一定为以下两种情况的一种：点到直线的最短距离、或点到线段某个端点的最短距离。

什么时候会遇到第二种情况呢？当且仅当点到直线的最短距离所对应的那个点不在线段上。

所以这道题一个最笨的方法就是：先根据线段求出直线两点式，然后求斜率乘积为-1（这样才能垂直）的直线，求出点斜式（还要特判斜率不存在的情况），这样求出两个直线交点，判断交点在不在线段上。如果在的话直接输出初始点到交点距离，否则输出初始点到线段两个端点的最小那个距离。

如果这道题用这种方法来做，计算量将非常大，题目难度也直接飙上1700+。事实上，本题有更简单的做法：

首先如何判断最终能不能取到点到直线距离呢？很简单，把点 PPP 和线段两个端点 AAA 和 BBB ，这三个点连接成一个三角形，判断该三角形的角 AAA 和角 BBB 是否是钝角即可。判断钝角可以直接用勾股定理：a2+b2<c2a^2+b^2<c^2a2+b2<c2 则角 CCC 为钝角。

然后如何求点到直线的距离呢？也很简单，PPP到直线ABABAB 的距离即三角形 PABPABPAB 中ABABAB边上的高。直接用 2∗SABC/AB2*S_{ABC}/AB2∗SABC/AB即可。而三角形面积可以直接用海伦公式：S=p∗(p−a)∗(p−b)∗(p−c),p=(a+b+c)/2S=\sqrt{p*(p-a)*(p-b)*(p-c)},p=(a+b+c)/2S=p∗(p−a)∗(p−b)∗(p−c),p=(a+b+c)/2。

可以发现，换一个做法，原本计算量巨大的题目将极大的减少做题的负担。在赛场上如果发现某题计算量非常大，不妨洗个脸冷静一下，换一个思路可能会豁然开朗。

*请注意，本题如果直接用网上的long long 存点的板子，可能会导致答案错误。因为在计算过程中会出现超过10^9的情况，这样在计算勾股定理的时候再一个平方就会出现爆long long精度的问题。解决办法要么使用__int128或者高精度，要么直接用double存点。 

7.欧拉降幂

一个长度为 nnn 的数组，显然有 2n−12^n-12n−1 个非空子序列。如果我们去枚举每个子序列然后求其权值，复杂度将到达恐怖的 O(n∗2n)O(n*2^n)O(n∗2n)，显然会超时。

我们可以观察到，当[排序]()了以后，如果确定了最大值和最小值，它们中间的数取不取对结果是没有影响的。因此，通过这种方式可以枚举最大值和最小值，中间的部分规约在一起，利用欧拉降幂进行计算，这样复杂度为 O(n2logn)O(n^2logn)O(n2logn)，这样还是不够。

我们看看这些指定了最大值和最小值的区间有什么特点呢？如果区间长度 (r−l+1)(r-l+1)(r−l+1) 为 kkk ，那么中间的数有【取】或【不取】两种状态，因此有 2k−22^{k-2}2k−2 的权值贡献。对于长度固定的情况，那么贡献的次数也就固定了。因此这部分可以利用乘法分配律合并起来。

这样我们最终只需要枚举区间长度就可以了。

举个例子，对于数组 [1,3,5,5,6] 而言（不妨设已经排好序了）。

我们枚举长度 2，最终带来的权值收益是 

(1∗3)20∗(3∗5)20∗(5∗5)20∗(5∗6)20(1*3)^{2^0}*(3*5)^{2^0}*(5*5)^{2^0}*(5*6)^{2^0}(1∗3)20∗(3∗5)20∗(5∗5)20∗(5∗6)20

我们枚举长度 3，最终带来的权值收益是 

(1∗5)21∗(3∗5)21∗(5∗6)21(1*5)^{2^1}*(3*5)^{2^1}*(5*6)^{2^1}(1∗5)21∗(3∗5)21∗(5∗6)21

我们枚举长度 4，最终带来的权值收益是 (1∗5)22∗(3∗6)22(1*5)^{2^2}*(3*6)^{2^2}(1∗5)22∗(3∗6)22

我们枚举长度 5，最终带来的权值收益是 (1∗6)23(1*6)^{2^3}(1∗6)23

根据公式 at∗bt=(a∗b)ta^t*b^t=(a*b)^tat∗bt=(a∗b)t，这些幂相同的底数都是可以合并的。合并之后我们发现，让枚举的长度变大的时候，它们的乘积是可以 O(logn)O(logn)O(logn)进行维护的，因为只除掉了两个数。这部分可以用逆元解决。（如果枚举的长度从大到小，甚至不需要逆元）

那么最终的问题就是怎么解决计算 x2yx^{2^y}x2y了。这就是这里要介绍的欧拉降幂：

根据费马小定理，当 aaa 和 ppp 互素时，有ap−1%p=1a^{p-1}\%p=1ap−1%p=1。

那么我们要计算aba^bab 模 ppp 的值，可以先把 bbb 写成 b=(p−1)u+vb=(p-1)u+vb=(p−1)u+v 的形式，即求 a(p−1)u+v=a(p−1)u∗ava^{(p-1)u+v}=a^{(p-1)u}*a^va(p−1)u+v=a(p−1)u∗av，前部分模 ppp为1，所以答案就是 ava^vav。v是什么？正是 bbb 对 p−1p-1p−1 取模的值。

也就是说，我们要求 ab%pa^b\%pab%p，如果 bbb 是个比较大的数（可能是个幂的形式），可以先让 bbb 对 (p−1)(p-1)(p−1) 取模，是不影响最终答案的正确性的（前提是 aaa 和 ppp 互素）。这个取模就叫做欧拉降幂。



2022-2-22
1.
string and sort:
#
一些数字，首尾相连，输出最大的组合：
sort(a,a+n,cmp)
bool cmp(string a,string b)
return a+b<b+a;